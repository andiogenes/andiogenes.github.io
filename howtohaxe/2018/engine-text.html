<p>Одно из целевых применений Haxe - разработка игр. Так как язык похож на ActionScript и изначально опирался на работу с Flash (ведущий разработчик языка и лидер проекта <a href="http://github.com/ncannasse">Nicolas Cannasse</a> изначально занимался флеш-играми и поддержкой технологии в компании <a href="https://motion-twin.com/en/">Motion Twin</a>), определенную долю его аудитории заняли Flash-разработчики, так как Haxe позволяет собирать под множество целевых платформ при помощи трансляции в код платформы, стало возможным использовать интерфейсы библиотеки AS3 для разработки под десктоп, мобильные устройства, HTML5 и т.д. Большой успех получил фреймворк <a href="http://www.openfl.org/">OpenFL</a>, представляющий перенос API Flash на Haxe, на его основе написаны порты игровых библиотек с AS3, такие как <a href="http://haxepunk.com/">HaxePunk</a> - порт движка FlashPunk, <a href="https://github.com/HaxeFlixel/flixel">HaxeFlixel</a> - порт Flixel. В последнее время большой интерес представляет фреймворк <a href="http://kha.tech/">Kha</a>, созданный с целью создания единой базы для разработки под всевозможные платформы, с интерфейсами для работы как на высоком уровне, так и на низком. Глубже со всеми этими библиотеками мы познакомимся чуть позже.</p>
<p>Haxe также не ограничивает разработчика в создании собственных инструментов, при помощи стандартных интерфейсов целевой платформы можно написать что угодно, в том числе, игровой движок. Мы напишем простенький "фреймворк" из двух классов, позволяющий отрисовывать примитивы и изображения, работать с нажатиями на клавиатуру, обновлять данные за короткий промежуток времени. Писать мы будем под JS.</p>
<h2>Подготовка. Интерфейсы HTML5 для работы с графикой</h2>
<p>Существует несколько способов динамической отрисовки в браузере. Один из наиболее простых из них - рисование через элемент <b>canvas</b> (холст) при помощи доступа к его контексту и соответствующим методам.<br>На JS работа с холстом осуществляется следующим образом:</p>
<code class="js">
	var canvas = document.body.getElementById("my-canvas");	// выборка элемента с тегом my-canvas <br>
	var context = canvas.getContext("2d");	// доступ к контексту 2D рендеринга canvas<br>
	context.fillStyle = "#ff0000";	// задаем цвет заливки - красный<br>
	context.fillRect(0, 0, 100, 50);	// рисуем прямоугольник с красным цветом фона<br>
</code>
<p>Подробная справка по интерфейсу контекста рендеринга представлена на сайте Mozilla: <a href="https://developer.mozilla.org/ru/docs/Web/API/CanvasRenderingContext2D">https://developer.mozilla.org/ru/docs/Web/API/CanvasRenderingContext2D</a></p>
<h2>Проектирование. На что будет способен наш "движок"</h2>
<p>По структуре проект представляет подобие движка <a href="https://love2d.org/">LÖVE</a>:<br>
У нас имеется базовый класс <b>Game</b>, который представляет методы для загрузки данных, обновления за промежуток времени, отрисовки графики, обработки нажатий клавиатуры.<br>
Также имеется класс <b>Graphics</b>, в котором мы инкапсулируем методы для отрисовки примитивов, изображений и текста.<br>
Пользовательский класс, содержащий игру, наследует <b>Game</b>, перегружая доступные методы.</p>
<h3>Список методов Game:</h3>
<ul><li>Конструктор <b>new</b>(name, width, height, color) - создает холст с id, указанным в аргументе "имя", заданной ширины, высоты и с заданным цветом фона, добавляет его к DOM, выполняет метод <b>init</b>, запускает игровой цикл, инициализируются обработчики нажатий клавиш.</li>
	<li><b>loop</b>() - вычисляет параметр dt - промежуток времени между прошлым вызовом <b>loop</b> и текущим, очищает экран для новой отрисовки экрана, вызывает метод <b>update</b> с переданным параметром dt, вызывает метод отрисовки draw, запрашивает у браузера запрос на повторный вызов себя <b>requestAnimationFrame</b>.</li>
	<li><b>init</b>() - перегружаемый метод, предназначенный для выполнения действий на инициализации игры.</li>
	<li><b>update</b>(dt) - перегружаемый метод, в котором каждый момент времени исполняется соответствующая логика. Аргумент dt передается сюда, т.к. разность между кадрами может серьезно пригодиться при реализации игровой логики и совместимости с слабыми компьютерами.</li>
	<li><b>draw</b>() - перегружаемый метод, в котором выполняется отрисовка экрана</li>
	<li><b>onKeyUp</b>(e), <b>onKeyDown</b>(e) - перегружаемые методы, осуществляющие действия при нажатии на клавиатуру, параметр <b>e</b> - информация о событии, в том числе, информация о нажатой клавише.</li>
	<li><b>setColor</b>(color), <b>getWidth</b>(), <b>getHeight</b>() - соответствующие методы для работы с экраном.</li>
	<li><b>isDown</b>(e) - проверка нажатия соответствующей клавиши (указывается код клавиши), возвращает true/false</li></ul>
<h3>Список методов Graphics:</h3>
<ul><li><b>setContext</b> - публичная статическая функция, меняющая статическую переменную текущего контекста, в котором происходит работа.</li>
	<li><b>setColor</b>(r, g, b) - установка цвета отрисовываемых примитивов в формате RGB.</li>
	<li><b>draw</b>(drawable, x, y, width, height, flipH, flipV) - отрисовка изображения заданного размера, в соответствующей точке, отраженную или нет по горизонтали/вертикали</li>
	<li><b>rectange</b>(x, y, w, h) - отрисовка прямоугольника заданных размеров</li>
	<li><b>print</b>(caption, x, y) - отрисовка текста с заданным содержимым</li>
</ul>
<p>О технической реализации поговорим попозже, т.к. я опаздываю, посмотреть код можно <a href="https://gist.github.com/andiogenes/6fa61f49a451df1f27d96eabcbe6a899">здесь</a></p>
<h2>Пример работы движка</h2>
<iframe src="../multimedia/platformer/index.html">Содержимое невозможно вывести, бразуер не поддерживает плавающие фреймы.</iframe>
<p><a href="../multimedia/platformer/index.html">Открыть в новом окне</a></p>